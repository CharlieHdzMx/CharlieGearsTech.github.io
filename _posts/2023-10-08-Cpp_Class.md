---
layout: post
title: C++ Class
excerpt: Article about C++ Class handling main features
modified: 5/07/2021, 9:00:24
tags:
  - Cpp
comments: true
category: blog
---
The cornerstone of Object-Oriented Programming (OOP) in C++ is the **class**. This article offers a concise introduction to classes and their key features, including access specifiers, encapsulation, constructors, destructors, copy constructors, and copy assignment operators. Additionally, we explore related concepts such as cascading member functions and the explicit keyword.

# Definition
In C++, **classes** and **structs** are defined as structured chunks of memory capable of storing a diverse set of data. They share principal features such as data members, member functions, and access specifiers.

The sole distinction between a class and a struct lies in the **default member access level**: class members are private by default, whereas struct members are public. To illustrate this, consider the following code snippet:

![01](https://github.com/CharlieHdzMx/CharlieHdzMx.github.io/assets/6202653/2771e009-bf26-4720-a659-81bdb5214516)

We have defined a Fraction class and a Byte struct for demonstration purposes, where you can observe the use of the terms "public" and "private." These terms are known as access specifiers, which determine the level of visibility and availability of class members. There are three access specifiers:

- **Public:** Public members can be accessed anywhere, including within the class definition file. If an object class instance is in scope, public static members in the class definition do not require an instance.
- **Protected:** Protected members can be accessed within the class definition or inside its derived class definitions.
- **Private:** Private members are only available to the class member functions and class friends within the class definition.

# Class Declaration and Definition
The class declaration serves as the blueprint for the class, encompassing variable declarations and function prototypes. Typically, class declarations are placed in a header file (.h), as demonstrated in the following snippet:

![02](https://github.com/CharlieHdzMx/CharlieHdzMx.github.io/assets/6202653/f894adca-9fc6-4637-9694-5d1f1442a8bb)

The class definition, also known as implementation, is where the functionality of the class is developed. It defines "what the class does" based on the functions and variables declared in the class declaration. Any definition outside the class necessitates the use of a scope resolution operator (ClassName::) before its name. To illustrate this, the following code displays the implementation of the Fraction class, incorporating the scope resolution operator:

```
double Fraction::toDouble(){
 
  return 1.0*(m_nNumerator/m_nDenominator);
}

//Don't you remember the const reference used as function parameter?﻿
//Check past articles﻿
//Two fraction addition﻿
Fraction& Fraction::add(const Fraction & other){

  Fraction tempFraction;
  if(m_nDenominator==other.m_nDenominator){
 
    tempFraction.m_nNumerator=m_nNumerator+other.m_nNumerator;
    tempFraction.m_nDenominator=m_nDenominator;
  }
 
  else{  
    tempFraction.m_nNumerator=(m_nNumerator*other.m_nDenominator)+(m_nDenominator*other.m_nNumerator);
    tempFraction.m_nDenominator=m_nDenominator*other.m_nDenominator;
  }
 
  return simplify(tempFraction);
}

//We wish to change f inside the function-so isn't a const reference
//in constrast than the last function﻿
//This function is ﻿awesome!!
﻿
Fraction& Fraction::simplify(Fraction& f){

//They may be static member also... but we're using them only here. 
  const int sizeArray=46;
  const int aPrimes[]={ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
                        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
                        101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
                        151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199 };
 
 
  for(int i=0; i< sizeArray;){
    //If we found a number which is the divisible for numerator and denominator
    if((f.numerator()%aPrimes[i]==0)&&(f.denominator()%aPrimes[i]==0))
      f.set(f.numerator()/aPrimes[i],f.denominator()/aPrimes[i]);
    
    else
      ++i;
  }
  return f;
}

//End
```

